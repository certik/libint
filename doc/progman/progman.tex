%
% The LIBINT Programmer's Manual
%

\documentclass[12pt]{article}
\usepackage{amsmath}

\begin{document}
\include{../macros}

\begin{center}
\ \\
\vspace{2.0in}
{\bf {\Large The \LIBINT\ Programmer's Manual}} \\
\vspace{0.5in}
Edward F.\ Valeev \\
\ \\
{\em Department of Chemistry, Virginia Tech, Blacksburg, Virginia 24061 USA}\\
\ \\
\vspace{0.3in}
\LIBINTv \\
Created on: \today
\end{center}

\thispagestyle{empty}

\newpage
\section{Introduction}
\LIBINT\ library contains functions to compute many-body integrals over Gaussian
functions which appear in electronic and molecular structure theories.
\LIBINTv \cite{Libint1}\ can currently compute several different types of integrals:

\begin{itemize}

\item Standard electron repulsion integrals (ERIs). This is by far the most common type of
integrals in molecular structure theory.

\item Two-electron integrals which appear in explicitly correlated R12 (or F12) methods
with Gaussian correlation factors.\cite{Kutzelnigg85,Kutzelnigg91,Persson96} All R12 methods, such as
MP2-R12, contain terms in the wave function that are depend on the interelectronic distances
$r_{ij}$ (hence the name). Appearance of several types of {\em two}-body integrals
is due to the use of the approximate resolution of the identity to reduce three- and four-body
integrals to products of simpler integrals.

\end{itemize}

The unique feature of \LIBINT\ library is that its source code is generated by a computer program, i.e., a {\em compiler}.
The purpose of the \LIBINT\ compiler is twofold.
First, it is to eliminate the tedious process of manual writing, debugging,
and optimizing the integrals code.
Instead, a programmer provides high-level specification of
operators and recurrence relations,\footnote{This currently
requires simple high-level programming, however in the future types of integral and recurrence relations
will be parsed from text specifications.}
and heuristics of how to apply the recurrence relations and the compiler takes care of the rest.
Second, the goal of the compiler is to make possible tailoring the code to existing
and future computer architectures. For example, some existing high-end processors
include vector units and many upcoming lower-end general and graphics processors
are promising to handle long double-precision vectors. Manual vectorization of a scalar integral code requires a lot of work,
however with \LIBINT\ the compiler can easily generate vectorized code at user's request. As the hardware
evolves, manual code reengineering can be avoided -- only the compiler needs to be modified.

The drawback of the \LIBINT\ approach is that generated code can be fairly large and thus take a long time to compile.
It is a relatively benign problem in practice.

\LIBINT\ currently implements recursive schemes based on Obara-Saika method\cite{Obara86} and Head-Gordon and Pople's
variation thereof.\cite{Head-Gordon88} Other recurrence relations can be easily implemented as needed.

Unlike version 1, which came as 3 separate interdependent libraries, version 2 of libint
comes as a single library configured at code-generation time.
The following features of the library can be configured:
\begin{itemize}
\item support for ERI
\item derivative level for ERI
\item support for G12 integrals
\item derivative level for G12 integrals
\item optimization features (whether shell-sets of integrals can be unrolled,
whether to perform Common Subexpression Elimination, etc.)
\item vectorization features
\item algorithmic features (evaluation strategy, cartesian shell ordering)
\item API features (name prefix, FLOP counter, whether to accumulate target integrals, floating-point type,
shall ordering of Cartesian basis functions)
\item shared library support
\end{itemize}
Depending on its configuration, the library may not include all features.

\section{\label{sec:notation} Notation}

Following Obara and Saika,\cite{Obara86}
we write an {\em unnormalized primitive Cartesian} Gaussian function centered at {\bf A}\ as
\begin{eqnarray}
\phi ({\bf r}; \zeta, \n, {\bf A}) & = & (x - A_x)^{n_x} (y - A_y)^{n_y} (z - A_z)^{n_z} \nonumber \\
& & \times \exp [-\zeta({\bf r}-{\bf A})^2]\ ,
\end{eqnarray}
where {\bf r}\ is the coordinate vector of the electron, $\zeta$ is the orbital exponent, and
\n\ is a set of non-negative integers. The sum of $n_x$, $n_y$, and $n_z$ will be denoted $\lambda(\n)$
and be referred to as the angular momentum or orbital quantum number of the Gaussian function.
Hereafter \n\ will be termed the angular momentum index.
Henceforth, $n_i$ will refer to the $i$-th component of \n, where $i \in \{x, y, z\}$.
Basic vector addition rules will apply to these vector-like triads of numbers, e.g.
$\n + {\bf 1}_x \equiv \{ n_x+1, n_y, n_z\}$.

A set of $(\lambda(\n) + 1)(\lambda(\n) + 2)/2$ functions with the same $\lambda(\n)$, $\zeta$, and centered
at the common center
but with different \n\ form a {\em Cartesian shell},
or just a {\em shell}. For example, an $s$ shell ($\lambda=0$) has one function, a $p$ shell ($\lambda=1$) --
3 functions, etc.
There is no unique choice for the order of functions in shells.
The standard \LIBINT\ ordering is:
\begin{eqnarray}
p & : & p_x, p_y, p_z \nonumber \\
d & : & d_{xx}, d_{xy}, d_{xz}, d_{yy}, d_{yz}, d_{zz} \nonumber \\
f & : & f_{xxx}, f_{xxy}, f_{xxz}, f_{xyy}, f_{xyz}, f_{xzz}, f_{yyy}, f_{yyz}, f_{yzz}, f_{zzz} \nonumber \\
{\rm etc.} \nonumber
\end{eqnarray}
In general, the following loop structure can be used to generate angular momentum indices in the canonical \LIBINT\ order for all
members of a shell of angular momentum {\tt am}:
\begin{verbatim}
for(int i=0; i<=am; i++) {
  int nx = am - i;  /* exponent of x */
  for(int j=0; j<=i; j++) {
    int ny = i-j;   /* exponent of y */
    int nz = j;     /* exponent of z */
  }
}
\end{verbatim}
Other shell orderings are supported as well, e.g., those employed by {\tt intv3} engine in {\tt MPQC} program
or the ordering used in {\tt GAMESS} program. These can be specified when the library is generated.
Support of new orderings are trivial to implement. If your program relies on an ordering different from the
above, please contact the author of \LIBINT .

The normalization constant for a primitive Gaussian $\phi ({\bf r}; \zeta, \n, {\bf A})$
\begin{eqnarray}
N(\zeta,\n) & = & \left[ \left(\frac{2}{\pi}\right)^{3/4}\frac{2^{(\lambda(\n))}\zeta^{(2\lambda(\n)+3)/4}}
                {[(2n_x-1)!!(2n_y-1)!!(2n_z-1)!!]^{1/2}} \right]
\end{eqnarray}

A contracted Gaussian function is just a linear combination of primitive Gaussians (also termed {\em primitives})
centered at the same center {\bf A} and with the same momentum indices {\bf n}
but with different exponents $\zeta_i$:
\begin{eqnarray}
\phi ({\bf r}; \bmath{\zeta}, {\bf C}, \n, {\bf A}) & = & (x - A_x)^{n_x} (y - A_y)^{n_y} (z - A_z)^{n_z} \nonumber \\
& & \times \sum_{i=1}^M C_i \exp [-\zeta_i ({\bf r}-{\bf A})^2]\ ,
\end{eqnarray}
Contracted Gaussians form shells the same way as primitives.
The contraction coefficients {\bf C} already include normalization constants so that the resulting combination
is properly normalized. Published contraction coefficients {\bf c} are linear coefficients for normalized primitives,
hence the normalization-including contraction coefficients {\bf C} have to be computed from them as
\begin{eqnarray} \label{eq:C1}
C_i & = & c_i N(\zeta_i,\n)
\end{eqnarray}
and scaled further so that the self-overlap of the contracted function is 1:
\begin{eqnarray} \label{eq:C2}
\frac{\pi^{3/2} (2n_x-1)!!(2n_y-1)!!(2n_z-1)!!}{2^{\lambda(\n)}}
\sum_{i=1}^M \sum_{j=1}^M \frac{C_i C_j }{(\zeta_i+\zeta_j)^{\lambda(\n)+3/2}} & = & 1
\end{eqnarray}

If sets of orbital exponents are used to form contracted Gaussians of one angular momentum only
then this is called a {\em segmented} contraction scheme. If there is a set of exponents that forms
contracted Gaussians of several angular momenta then such scheme is called {\em general} contraction.
Examples of basis sets that include general contractions include Atomic Natural Orbitals (ANO) sets.
\LIBINT\ was not designed to handle general contractions very well. You should use either split general contractions
into segments for each angular momentum (it's done for correlation consistent basis sets)
or use basis sets with segmented contractions only.

An integral of a two-electron operator $\hat{O}({\bf r}_1, {\bf r}_2)$ over unnormalized
primitive Cartesian Gaussians is written as
\begin{eqnarray}
\int \phi({\bf r}_1; \zeta_a, {\bf a}, {\bf A}) \phi ({\bf r}_2; \zeta_c, {\bf c}, \C) \hat{O}({\bf r}_1, {\bf r}_2)
\phi({\bf r}_1; \zeta_b, {\bf b}, \B) \phi({\bf r}_2; \zeta_d, {\bf d}, \D) d{\bf r}_1 d{\bf r}_2 \equiv ({\bf ab} |\hat{O}|{\bf cd})
\end{eqnarray}
A set of integrals $\{ ({\bf a} {\bf b}|\hat{O}({\bf r}_1, {\bf r}_2)|{\bf c} {\bf d}) \}$
over all possible combinations of functions ${\bf a} \in {\rm Shell A}$, ${\bf b} \in {\rm Shell B}$, etc.
will be termed a {\em shell-set}, or simply a {\em set}, of integrals. For example, a $(ps|sd)$ set consists of
$3 \times 1 \times 1 \times 6 = 18$ integrals.

The following definitions have been used throughout this work:
\begin{eqnarray}
\zeta & = & \zeta_a + \zeta_b \\
\eta  & = & \zeta_c + \zeta_d \\
\rho  & = & \frac{\zeta\eta}{\zeta+\eta} \\
{\bf P}& = & \frac{\zeta_a {\bf A} + \zeta_b \B}{\zeta} \\
{\bf Q}& = & \frac{\zeta_c \C + \zeta_d \D}{\eta} \\
{\bf W}& = & \frac{\zeta {\bf P} + \eta {\bf Q}}{\zeta+\eta}
\end{eqnarray}
The Boys function is defined as
\begin{eqnarray}
F_m(T) & = & \int_0^{1} dt\ t^{2m}\ \exp (-Tt^2)
\end{eqnarray}

Evaluation of integrals over functions of non-zero angular momentum starts with the
{\em auxiliary} integrals over primitive $s$-functions
defined as
\begin{eqnarray}
\label{eq:0000m}
({\bf 00}|{\bf 00})^{(m)} & = & 2 F_m(\rho |{\bf PQ}|^2) \sqrt{\frac{\rho}{\pi}}S_{12}S_{34}
\end{eqnarray}
where ${\bf PQ} = {\bf P} - {\bf Q}$ and primitive overlaps $S_{12}$ and $S_{34}$
are computed as
\begin{eqnarray}
S_{12} & = & \Bigl( \frac{\pi}{\zeta} \Bigr)^{3/2}
\exp \Bigl(-\frac{\zeta_a\zeta_b}{\zeta} |{\bf AB}|^2 \Bigr) \\
S_{34} & = & \Bigl( \frac{\pi}{\eta} \Bigr)^{3/2}
\exp \Bigl(-\frac{\zeta_c\zeta_d}{\eta} |{\bf CD}|^2 \Bigr)
\end{eqnarray}
In the evaluation of integrals over contracted functions it is convenient to
use auxiliary integrals over primitives which include contraction and normalization factors of the
target quartet $({\bf ab}|{\bf cd})$:
\begin{eqnarray} \label{eq:0000m}
({\bf 00}|{\bf 00})^{(m)} & = &  2 F_m(\rho |{\bf PQ}|^2) \sqrt{\frac{\rho}{\pi}}S_{12}S_{34}
C_1 C_2 C_3 C_4
\end{eqnarray}
where the coefficients $C_a$, $C_b$, $C_c$, and $C_d$ are
normalization-including contraction coefficients (Eqs. (\ref{eq:C1})
and (\ref{eq:C2})) for the first basis function out of each respective shell
in the target shell of integrals.

\section{Overview of \LIBINT 's API}

({\bf Note}: Depending on configuration, \LIBINT\ may also support computation of other, non-ERI types of integrals. Here I will describe
the parts of the interface which deals with ERIs only. The rest of the API is very similar to what's described here.)

\LIBINT\ library is a low-level C++ code. C linking convention is adopted to enable interoperability with other languages, such as C and FORTRAN.
For notes on how to use \LIBINT\ library from FORTRAN code, see subsection \ref{ssec:fort}.

\LIBINT\ API consists of 3 major components: type definitions, function and variable prototypes, and C preprocessor macros.
The API is described in the following header files:
\begin{itemize}
\item \libinth\ -- main header file, it includes all other headers (not generated).
\item \libintinttypesh\ -- architecture-specific definitions for long integer types (not generated).
\item \libinttypesh\ -- definitions for the integral evaluator types (generated).
\item \libintparamsh\ -- C preprocessor macros for library features (generated).
\item \libintifaceh\ -- prototypes for functions and data as well as some misc macros (generated).
\end{itemize}
\libinth is the only header that must be included explicitly in the user code.

The preprocessor macros provided by \libinth\ are necessary so that the user code can
access the library configuration parameters. For example, the library can be configured at the code generation time
to support in principle any finite angular momentum of the basis functions. The user code must still
test whether the maximum angular momentum present in the basis set exceeds the library limit.

The preprocessor value macros provided by \libinth\ are listed in Figure \ref{fig:valmacros}
\begin{figure}
\caption{\label{fig:valmacros} C preprocessor value macros provided by \libinth .}
\begin{center}
\begin{minipage}[t]{0.9\linewidth}
\begin{verbatim}
#define LIBINT2_REALTYPE <C++ floating-point type>
#define LIBINT2_MAX_VECLEN <positive integer>
#define LIBINT2_API_PREFIX <string>

/* ERI-specific macros */
#define LIBINT2_SUPPORT_ERI <0 or 1>
#define LIBINT2_MAX_AM_ERI <nonnegative integer>
#define LIBINT2_DERIV_ERI_ORDER <nonnegative integer>
\end{verbatim}
\end{minipage}
\end{center}
\end{figure}
where the angled brakets describe valid macro values.
The most important macro, {\tt LIBINT2\_REALTYPE}, specifies the floating-point type
used by the library for all computations (usually, {\tt double}).
The next macro, {\tt LIBINT2\_MAX\_VECLEN} specifies the maximum vector length supported by the library. For the scalar code
this macro will be set to 1, whereas for the vectorized library this will have a value greater than
1.
The next macro, {\tt LIBINT2\_API\_PREFIX}, is used by the {\tt LIBINT2\_PREFIXED\_NAME} function macro and should not be
used explicitly (I list it here for reference).
The last three macros describe whether the library supports computation of the electron repulsion integrals,
the maximum angular momentum of the basis functions supported for the ERI code (value of 3 corresponds to support
of up to $f$ functions, etc.), and the maximum order of the
ERI derivatives which can be computed (currently only 0 is supported).

\LIBINT\ API also specifies several functions and variables whose decralations are listed in Figure \ref{fig:api}.
\begin{figure}
\caption{\label{fig:api} \LIBINT\ API  functions and data (N equals {\tt LIBINT2\_MAX\_AM\_ERI} + 1). }
\begin{center}
\begin{minipage}[t]{0.9\linewidth}
\begin{verbatim}
void libint2_static_init();
void libint2_static_cleanup();

/* ERI-specific API */
void libint2_init_eri(Libint_eri_t* libint, int max_am, LIBINT2_REALTYPE* buf);
void libint2_cleanup_eri(Libint_eri_t* libint);
size_t libint2_need_memory_eri(int max_am);
void (*libint2_build_eri[N][N][N][N])(Libint_eri_t *);
\end{verbatim}
\end{minipage}
\end{center}
\end{figure}
The first two functions perform static initialization and cleanup of the library.
Thus {\tt libint2\_static\_init} must be called before \LIBINT\ is used and
{\tt libint2\_static\_cleanup} must be called after \LIBINT\ is no longer needed (only one thread needs to call these functions).
The next two functions are used to initialize and deinitialize the key data
structure ({\em integral evaluator}) involved in the computation of the electron repulsion integrals.
To initialize the integral evaluator, {\tt libint2\_init\_eri} should be called with three arguments:
1) the pointer to the evaluator to be initialized; 2) the maximum angular momentum
of basis functions this object will support ({\tt max\_am} will affect the memory requirements
for the computation and therefore should be always set to the actual maximum value needed,
not the maximum value supported by the library); 3) optional pointer to the scratch buffer
which will be used to hold intermediate results. If the third argument is 0, then
the call will dynamically allocate the needed space. If the user code needs to control
memory allocation/deallocation, the scratch buffer needs to be allocated prior to the call.
{\tt libint2\_need\_memory\_eri} can be used to compute the required size of
the scratch buffer in units of {\tt LIBINT2\_REALTYPE}. Lastly, {\tt libint2\_build\_eri} is a 4-dimensional
array of pointers to functions which evaluate ERIs, e.g., {\tt libint2\_build\_eri[1][0][2][0](\&erieval)}
will compute the $(ps|ds)$ set using evaluator {\tt erieval} ({\tt erieval} must have been initialized
with {\tt libint2\_init\_eri}).

\LIBINT\ API I have described so far is very simple. However, as you may have noticed, there has been no mention of
where the basis set data is stored. This is because \LIBINT\ does not maintain the basis set information.
As part of \LIBINT 's philosophy to provide the leanest possible code, the user code
is in charge of precomputing basis set data and Boys function values and then feeding it to the evaluator object
of type {\tt Libint\_eri\_t}.

The definition of {\tt Libint\_eri\_t} is shown in Figure \ref{fig:libintt}.
\begin{figure}
\caption{\label{fig:libintt} ``External'' parts of the definition of the \LIBINT\ integral evaluator type. }
\begin{center}
\begin{minipage}[t]{0.9\linewidth}
\begin{verbatim}
typedef struct {
  _aB_s__0__s__1___TwoERep_s__0__s__1___Ab__up_0[VECLEN];
  _aB_s__0__s__1___TwoERep_s__0__s__1___Ab__up_1[VECLEN];
  _aB_s__0__s__1___TwoERep_s__0__s__1___Ab__up_2[VECLEN];
  _aB_s__0__s__1___TwoERep_s__0__s__1___Ab__up_3[VECLEN];
  _aB_s__0__s__1___TwoERep_s__0__s__1___Ab__up_4[VECLEN];
  /* and so on until 4 * LIBINT2_MAX_AM_ERI */

  LIBINT2_REALTYPE WP_x[VECLEN], WP_y[VECLEN], WP_z[VECLEN];
  LIBINT2_REALTYPE WQ_x[VECLEN], WQ_y[VECLEN], WQ_z[VECLEN];
  LIBINT2_REALTYPE PA_x[VECLEN], PA_y[VECLEN], PA_z[VECLEN];
  LIBINT2_REALTYPE QC_x[VECLEN], QC_y[VECLEN], QC_z[VECLEN];
  LIBINT2_REALTYPE AB_x[VECLEN], AB_y[VECLEN], AB_z[VECLEN];
  LIBINT2_REALTYPE CD_x[VECLEN], CD_y[VECLEN], CD_z[VECLEN];

  LIBINT2_REALTYPE oo2z[VECLEN];
  LIBINT2_REALTYPE oo2e[VECLEN];
  LIBINT2_REALTYPE oo2ze[VECLEN];
  LIBINT2_REALTYPE roz[VECLEN];
  LIBINT2_REALTYPE roe[VECLEN];
  
  LIBINT2_REALTYPE* stack;   /* used internally */
  LIBINT2_REALTYPE* vstack;  /* used internally */
  LIBINT2_REALTYPE* targets[LIBINT2_MAX_NTARGETS_eri];
  int veclen;

  LIBINT2_UINT_LEAST64 nflops;
  int zero_out_targets;
} Libint_eri_t;
\end{verbatim}
\end{minipage}
\end{center}
\end{figure}
{\tt Libint\_eri\_t} is a C structure, i.e., its members can be manipulated directly.
This is done to allow direct manipulation of {\tt Libint\_eri\_t} from
Fortran and other languages.
Note that only ERI-specific parts of the actual definition {\tt Libint\_eri\_t} are shown in Figure \ref{fig:libintt}.
Currently, the same data structure is used for all types of evaluators (i.e. for ERI evaluators
and Gaussian geminal type evaluators), i.e. {\tt Libint\_eri\_t} contains also members which are only used
for evaluation of Gaussian geminal integrals also. In the future the evaluator types will be generated
automatically and will be specific to each type of computation.

Let's look in detail at the members of {\tt Libint\_eri\_t} which must be precomputed before
calling the relevant {\tt libint2\_build\_eri} function:
\begin{itemize}
\item {\tt \_aB\_s\_\_0\_\_s\_\_1\_\_\_TwoERep\_s\_\_0\_\_s\_\_1\_\_\_Ab\_\_up\_m} --
values of auxiliary primitive integrals $({\bf 00}|{\bf 00})^{(m)}$ (Eq. (\ref{eq:0000m}))
for $0 \leq m \leq \lambda({\bf a}) + \lambda({\bf b}) + \lambda({\bf c}) + \lambda({\bf d}) + C$,
where $C = 0$ when computing ERIs, $C=1$ when computing first derivative ERIs, etc.
\item {\tt AB\_i}, {\tt CD\_i} -- cartesian components of vectors ${\bf AB} \equiv {\bf A} - {\bf B}$
and ${\bf CD} \equiv {\bf C} - {\bf D}$.
\item {\tt PA\_i}, {\tt QC\_i} -- cartesian components of vectors ${\bf PA} \equiv {\bf P} - {\bf A}$
and ${\bf QC} \equiv {\bf Q} - {\bf C}$.
\item {\tt WP\_i}, {\tt WQ\_i} -- cartesian components of vectors ${\bf WP} \equiv {\bf W} - {\bf P}$
and ${\bf WQ} \equiv {\bf W} - {\bf Q}$.
\item {\tt oo2z} -- $\frac{1}{2\zeta}$
\item {\tt oo2n} -- $\frac{1}{2\eta}$
\item {\tt oo2zn} -- $\frac{1}{2(\zeta+\eta)}$
\item {\tt roz} -- $\frac{\rho}{\zeta}$
\item {\tt ron} -- $\frac{\rho}{\eta}$
\end{itemize}
Most of these quantities are simple to evaluate. Evaluation of the Boys function needed to compute
the auxiliary integrals $({\bf 00}|{\bf 00})^{(m)}$ is more involved.
One should consult external sources for information on how
to compute it efficiently.\cite{Gill91,TaylorInterpolation,IshidaFm}

After the integrals have been built, they are placed somewhere in the scratch buffer.
To recover their location, the array of pointers {\tt targets} is provided, e.g.,
the computed ERI shell-set is located at {\tt target[0]}.
ERI evaluation produces only one shell-set of integrals, but other types of computations
may produce several shell-sets of integrals at a time, e.g., usually all 12 derivative
ERI integrals are computed at the same time. That's why {\tt target} is an array of pointers, not a pointer.

Shell-sets of integrals contain integrals in ``row major'' order.\cite{KnuthACP} For example, if
the number of functions in each shell is $n_a$, $n_b$, $n_c$, and $n_d$, respectively,
then the integral $(ab|cd)$ is found at position $abcd = ( (a n_b + b) n_c + c) n_d + d$.

The rest of {\tt Libint\_eri\_t} is used to control various aspects of its behavior:
\begin{itemize}
\item {\tt veclength} is used in vectorized computation of integrals.
\item {\tt nflops} is used to count the total number of FLOPs (the library must have been configured
  with {\tt --enable-flop-counter}).
\item {\tt zero\_out\_targets} is used to zero out the target integral buffers. This is only useful
  if \LIBINT\ was configured with {\tt --enable-accum-ints}.
\end{itemize}

{\bf Note} that currently \LIBINT\ has a very important restriction on the angular momentum ordering of the functions
in shell quartets that it can handle. \LIBINT\ can evaluate a shell quartet
$({\bf ab}|{\bf cd})$ if $\lambda({\bf a}) \geq \lambda({\bf b})$,
$\lambda({\bf c}) \geq \lambda({\bf d})$, and $\lambda({\bf c}) + \lambda({\bf d}) \geq \lambda({\bf a}) + \lambda({\bf b})$.
If one needs to compute a quartet that doesn't conform the rule, e.g. of type $(pf|sd)$,
permutational symmetry of integrals can be utilized to compute such quartet:\footnote{Note that some
of the integrals that \librij\ computes possess different permutational symmetries than ERIs. One can still
compute all desired integrals in that case.}
\begin{eqnarray}
(pq|rs) = (pq|sr) = (qp|rs) = (qp|sr) = (rs|pq) = (rs|qp)= (sr|pq) = (sr|qp)
\end{eqnarray}
In the case of $(pf|sd)$ shell quartet, one computes quartet $(ds|fp)$ instead, and then
permutes function indices back to obtain the desired $(pf|sd)$.

The final integrals that \LIBINT\ computes are not normalized. The best way to include the normalization
is to scale the auxiliary integrals $({\bf 00}|{\bf 00})^{(m)}$ by the normalization factors.
However, Gaussians in a shell of angular momentum $>1$ have different normalization factors.
Usually the convention is to use the normalization factor for the functions which have all quanta along
one Cartesian direction, e.g., $d_{xx}, f_{xxx}$, etc.

\section{Example: using \libint}

A C++ function which uses \LIBINT\ is shown in Listing 1.

\begin{footnotesize}
Listing 1: Using \LIBINT\ from C++ code.
\begin{verbatim}
#include <iostream>
#include <algorithm>
#include <libint2.h>

using namespace std;

/** This function evaluates ERI over 4 primitive Gaussians.
    Normalization is not included here. */
void compute_eri(unsigned int am1, double alpha1, double A[3],
                 unsigned int am2, double alpha2, double B[3],
                 unsigned int am3, double alpha3, double C[3],
                 unsigned int am4, double alpha4, double D[3]
                )
{
    // I will assume that libint2_static_init() has been called elsewhere!

    // The ERI evaluator would normally be allocated once per calculation,
    // not once every integral shell-set
    Libint_eri_t erieval;
    const unsigned int max_am = max(max(am1,am2),max(am3,am4));
    libint2_init_eri(&erieval,max_am,0);

    //
    // Compute requisite data -- many of these quantities would be precomputed
    // for all nonnegligible shell pairs somewhere else
    //
    const double gammap = alpha1 + alpha2;
    const double Px = (alpha1*A[0] + alpha2*B[0])/gammap;
    const double Py = (alpha1*A[1] + alpha2*B[1])/gammap;
    const double Pz = (alpha1*A[2] + alpha2*B[2])/gammap;
    const double PAx = Px - A[0];
    const double PAy = Py - A[1];
    const double PAz = Pz - A[2];
    const double PBx = Px - B[0];
    const double PBy = Py - B[1];
    const double PBz = Pz - B[2];
    const double AB2 = (A[0]-B[0])*(A[0]-B[0])
                     + (A[1]-B[1])*(A[1]-B[1])
                     + (A[2]-B[2])*(A[2]-B[2]);
    
    erieval.PA_x[0] = PAx;
    erieval.PA_y[0] = PAy;
    erieval.PA_z[0] = PAz;
    erieval.AB_x[0] = A[0] - B[0];
    erieval.AB_y[0] = A[1] - B[1];
    erieval.AB_z[0] = A[2] - B[2];
    erieval.oo2z[0] = 0.5/gammap;
    
    const double gammaq = alpha3 + alpha4;
    const double gammapq = gammap*gammaq/(gammap+gammaq);
    const double Qx = (alpha3*C[0] + alpha4*D[0])/gammaq;
    const double Qy = (alpha3*C[1] + alpha4*D[1])/gammaq;
    const double Qz = (alpha3*C[2] + alpha4*D[2])/gammaq;
    const double QCx = Qx - C[0];
    const double QCy = Qy - C[1];
    const double QCz = Qz - C[2];
    const double QDx = Qx - D[0];
    const double QDy = Qy - D[1];
    const double QDz = Qz - D[2];
    const double CD2 = (C[0]-D[0])*(C[0]-D[0])
                     + (C[1]-D[1])*(C[1]-D[1])
                     + (C[2]-D[2])*(C[2]-D[2]);
    
    erieval.QC_x[0] = QCx;
    erieval.QC_y[0] = QCy;
    erieval.QC_z[0] = QCz;
    erieval.CD_x[0] = C[0] - D[0];
    erieval.CD_y[0] = C[1] - D[1];
    erieval.CD_z[0] = C[2] - D[2];
    erieval.oo2e[0] = 0.5/gammaq;
    
    const double PQx = Px - Qx;
    const double PQy = Py - Qy;
    const double PQz = Pz - Qz;
    const double PQ2 = PQx*PQx + PQy*PQy + PQz*PQz;
    const double Wx = (gammap*Px + gammaq*Qx)/(gammap+gammaq);
    const double Wy = (gammap*Py + gammaq*Qy)/(gammap+gammaq);
    const double Wz = (gammap*Pz + gammaq*Qz)/(gammap+gammaq);
    
    erieval.WP_x[0] = Wx - Px;
    erieval.WP_y[0] = Wy - Py;
    erieval.WP_z[0] = Wz - Pz;
    erieval.WQ_x[0] = Wx - Qx;
    erieval.WQ_y[0] = Wy - Qy;
    erieval.WQ_z[0] = Wz - Qz;
    erieval.oo2ze[0] = 0.5/(gammap+gammaq);
    erieval.roz[0] = gammapq/gammap;
    erieval.roe[0] = gammapq/gammaq;
    
    double K1 = exp(-alpha1*alpha2*AB2/gammap);
    double K2 = exp(-alpha3*alpha4*CD2/gammaq);
    double pfac = 2*pow(M_PI,2.5)*K1*K2/(gammap*gammaq*sqrt(gammap+gammaq));

    //
    // calc_f (not shown here) evaluates Boys function F_m for all m in [0,am]
    //
    unsigned int am = am1 + am2 + am3 + am4;
    double* F = init_array(am+1);
    calc_f(F,am,PQ2*gammapq);

    // (00|00)^m = pfac * F_m
    erieval.LIBINT_T_SS_EREP_SS(0)[0] = pfac*F[0];
    erieval.LIBINT_T_SS_EREP_SS(1)[0] = pfac*F[1];
    erieval.LIBINT_T_SS_EREP_SS(2)[0] = pfac*F[2];
    erieval.LIBINT_T_SS_EREP_SS(3)[0] = pfac*F[3];
    erieval.LIBINT_T_SS_EREP_SS(4)[0] = pfac*F[4];
    // etc.

    // compute ERIs
    libint2_build_eri[am1][am2][am3][am4](&erieval);

    // Print out the integrals
    const double* eri_shell_set = erieval.targets[0];
    const unsigned int n1 = (am1 + 1)(am1 + 2)/2;
    const unsigned int n2 = (am2 + 1)(am2 + 2)/2;
    const unsigned int n3 = (am3 + 1)(am3 + 2)/2;
    const unsigned int n4 = (am4 + 1)(am4 + 2)/2;
    for(int a=0; a<n1; a++) {
      for(int b=0; b<n2; b++) {
        for(int c=0; c<n3; c++) {
          for(int d=0; d<n4; d++) {
            cout << ``a = `` << a
                 << ``b = `` << b
                 << ``c = `` << c
                 << ``d = `` << d
                 << ``(ab|cd) = `` << *eri_shell_set;
            ++eri_shell_set;
          }
        }
      }
    }

    libint2_cleanup_eri(&erieval);
}
\end{verbatim}
\end{footnotesize}

\section{\label{sec:fort} Notes on using \LIBINT\ from Fortran}

Although \LIBINT\ source is written in C++, it should be possible to use the library
from Fortran programs. (Un)fortunately, I am not a Fortran programmer. Thus I can
only provide general guidelines here.

One of the main issues is the number of Fortran standards available. The most recent standard, Fortran 2003,
seems to have the best support for interoperability with C programs, but its compiler support is stil lacking.
Unfortunately, the most popular standard, Fortran 77, is also the most restrictive.

In general, C functions can be easily called from Fortran programs, but sharing data structures
is not straightforward. Thus the main culprit is how to modify  {\tt Libint\_eri\_t} objects
from Fortran. Fortran 2003 provides direct support for binding C data structures to
Fortran types. Older Fortran standards can access C data structures indirectly, via
common blocks. An (non-working) example of how a Fortran subroutine can manipulate {\tt Libint\_eri\_t}
is shown in Listing 2.

\begin{footnotesize}
Listing 2: Accesing {\tt Libint\_eri\_t} structure from a Fortran code.

{\bf C++ code}
\begin{verbatim}
      extern Libint_eri_t erieval;
\end{verbatim}

{\bf Fortran code}
\begin{verbatim}
       c assuming that LIBINT2_REALTYPE is 8-bytes long
       real(8) F0(1)
       real(8) F1(1)
       real(8) F2(1)
       real(8) F3(1)
       real(8) F4(1)
       etc.
       real(8) WP_x(1), WP_y(1), WP_z(1)
       real(8) WQ_x(1), WQ_y(1), WQ_z(1)
       real(8) PA_x(1), PA_y(1), PA_z(1)
       real(8) QC_x(1), QC_y(1), QC_z(1)
       real(8) AB_x(1), AB_y(1), AB_z(1)
       real(8) CD_x(1), CD_y(1), CD_z(1)
       real(8) oo2z(1), oo2e(1), oo2ze(1), roz(1), roe(1)
       c in 64-bit environment pointers are 8-bytes long
       c assuming LIBINT2_MAX_NTARGETS is 10
       integer(8) targets(10)
       integer(4) veclength
       integer(8) nflops
       integer(4) zero_out_targets
       c common erieval represents the C object erieval
       common/erieval/ F0, F1, ... , WP_x, WP_y, etc.

       c now can access elements of erieval
       AB_x[0] = Ax[0] - Bx[0]
       etc.
\end{verbatim}
\end{footnotesize}

The caveat of accessing C data structures from Fortran programs is that the members of the data structure must be
declared in the common block in the exact order in which they appear in the definition of {\tt Libint\_eri\_t}.
The actual definition of {\tt Libint\_eri\_t} in \libinttypesh\ must always be consulted.

Calling \LIBINT\ functions from Fortran should be straightforward. Using the function pointer array {\tt libint2\_build\_eri} is probably
not feasible in older Fortran standards, but perhaps can be accomplished in Fortran 2003. Actual function names must be used instead, i.e.,
a C++ expression
\begin{verbatim}
libint2_build_eri[1][0][2][0](&erival);
\end{verbatim}
will be replaced with a Fortran expression (I'm not sure how to pass pointer to erieval to the function from Fortran!)
\begin{verbatim}
_aB_p__0__d__1___TwoERep_s__0__s__1___Ab__up_0()
\end{verbatim}
where {\tt \_aB\_p\_\_0\_\_d\_\_1\_\_\_TwoERep\_s\_\_0\_\_s\_\_1\_\_\_Ab\_\_up\_0} is the name of the function
to which {\tt libint2\_build\_eri[1][0][2][0]} points.

Please send in your comments on how to actually make \LIBINT\ work from Fortran.

\bibliographystyle{unsrt}
\bibliography{refs}

\end{document}
